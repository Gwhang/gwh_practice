package com.example.demo.pattern.bridging;

import java.math.BigDecimal;

/**
 * 什么是桥接模式？
 * 桥接模式的主要作用就是通过将抽象部分与实现部分分离，把多种可匹配的使用进行组合。
 * 说白了核⼼心实现也就是在A类中含有B类接口，通过构造函数传递B类的实现，这个B类就是设计的桥 。
 *
 * 开发中应用场景？
 * JDBC多种驱动程序的实现、同品牌类型的台式机和笔记本平板、业务实现中的多类接口同组过滤服务等。
 * 这些场景都⽐比较适合使用桥接模式进行实现，因为在一些组合中如果有如果每一个类都实现不不同的服务可能会出现笛卡尔积，
 * 而使用桥接模式就可以非常简单。
 *
 * 举例说明
 * 支付方式有：支付宝，微信。支付模式有：刷脸、密码、指纹。支付方式和支付模式的融合应用，，
 * 如果给每一个支付都实现一次不不同的模式，即使是继承类也需要开发好多。
 * 而且随着后面接入了更多的支付服务或者支付方式，就会呈爆炸似的扩展。
 *
 * 桥接模式一共有4个角色
 * 抽象化角色 : pay
 * 修正抽象化角色 ：WxPay，ZfbPay
 * 实现化角色：IPayMode
 * 具体实现化角色：PayFaceMode、PayFingerprintMode、PayCypher
 *
 */
public class Test {

    /**
     * 总结
     * 通过模拟微信与⽀付宝两个⽀付渠道在不同的支付模式下，
     * 刷脸 、 指纹 、 密码 ，的组合从⽽而体现了桥接模式的在这类场景中的合理运用。
     * 简化了代码的开发，给后续的需求迭代增加了很好的扩展性。
     *
     * 从桥接模式的实现形式来看满⾜了单一职责和开闭原则，让每⼀部分内容都很清晰易于维护和拓展，
     * 但如果我们是实现的⾼内聚的代码，那么就会很复杂。所以在选择重构代码的时候，需要考虑好整体的设计，
     * 否则选不到合理的设计模式，将会让代码变得难以开发
     *
     * 任何⼀种设计模式的选择和使用都应该遵顼符合场景为主，不要刻意使用。
     * 而且统⼀场景因为业务的复杂从而可能需要使⽤到多种设计模式的组合，
     * 才能将代码设计的更加合理。但这种经验需要从实际的项⽬中学习经验，并提不断的运用。
     *
     *
     * @param args
     */
    public static void main(String[] args) {
        System.out.println("模拟测试场景；微信支付、人脸方式。");
        Pay wxPay = new WxPay(new PayFaceMode());
        wxPay.transfer("weixin_1092033111", "100000109893", new BigDecimal(100));

        System.out.println("模拟测试场景；支付宝支付、指纹方式。");
        Pay zfbPay = new ZfbPay(new PayFingerprintMode());
        zfbPay.transfer("jlu19dlxo111","100000109894",new BigDecimal(100));
    }

}
